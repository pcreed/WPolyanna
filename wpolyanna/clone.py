import itertools as it

from wpolyanna.op import Operation, ExplicitOperation, Projection

class Clone:
    """ A class to represent a clone of operations.

    :param arity: The arity of the clone.
    :type arity: integer
    :param ops: The operations in the clone.
    :type ops: :py:func:`list` of :class:`Operation`
    """
        
    def __init__(self,ops,arity=None,dom=None):
        """
        Create a new clone object.
        """
        
        self.ops = ops
        if dom is None and len(ops) > 0:
            self.dom = ops[0].dom
        else:
            self.dom = dom
        if arity is None and len(ops) > 0:
            self.arity = ops[0].arity
        else:
            self.arity = arity

        if len(ops) == 0:
            self.ops = [Projection(self.dom,self.arity,i) for i in range(self.arity)]
        
    def __repr__(self):
        return "Clone(%s)" % str(self.ops)
    
    def __getitem__(self,i):
        """ Return the i-th operation in this clone. """
        return self.ops[i]

    def __len__(self):
        """ Return the number of operations in this clone. """
        return len(self.ops)

    def __eq__(self,other):
        """ Test if this clone is equal to another. """

        if (self.dom != other.dom
            or self.arity != other.arity
            or len(self) != len(other)):
            return False

        S = self.ops
        T = other.ops
        for f in S:
            try:
                T.remove(f)
            except ValueError:
                return False
        return True

    def index(self,f):
        """ Return the index of a particular Operation in this clone. """
        return self.ops.index(f)

    @staticmethod
    def all_operations(arity,dom):
        """ Return the clone of all operations.

        :param arity: the arity
        :type arity: int
        :param dom: the domain size
        :type dom: int       
        """
        
        D = range(dom)
        tuples = []
        for x in it.product(D,repeat=arity):
            tuples.append(x)
        ops = [Projection(arity,dom,i) for i in range(arity)]
        for vals in it.product(D,repeat=len(tuples)):
            fmap = dict()
            for i in range(len(tuples)):
                fmap[tuples[i]] = vals[i]
            f = ExplicitOperation(arity,dom,fmap)
            if not f.is_projection():
                ops.append(f)
        return Clone(ops)

    #@staticmethod
    #def generate(F,arity,log=False):
        #""" Compute the arity arity clone generated by F.

        #:param F: the set of operations
        #:type F: list of Operation
        #:param arity: the arity
        #:type arity: int
        #"""
        #count = arity
        #dom = F[0].dom
        
        #C = [Projection(arity,dom,i) for i in range(arity)]
        
        # Close under compositions
        # Repeat until no new operations added
        #changed = True
        #while changed:
        #    changed = False
        #    for f in F:
        #        for t in it.permutations(C,f.arity):
        #            g = f.compose(t)
        #            if not g in C:
        #                if log:                            
        #                    count += 1
        #                    print g,count
        #                C.append(g)
        #               changed = True
        #if log:
        #    print count
        #return Clone(C)
    
    @staticmethod
    def generate(F,arity,log=False):
        """
        Generate the operations of some arity arity in the clone generated
        by F.
        """
        dom = F[0].dom
        if log:
            count = 0;
        
        # Always want to have all projections
        C = [Projection(arity,dom,i) for i in range(arity)]

        # Add all restrictions of elements of F to the required arity
        for f in F:
            for t in it.product(C[0:arity],repeat=f.arity):
                g = f.compose(t)
                if not g in C:
                    if log:                    
                        print (count,g)
                        count += 1
                    C.append(g)

        # Generate elements by iteration
        # For each f,g in C we compute the operation h in which
        # g is substituted for the i-th input of f, adding if it
        # is not in the clone.
        # This procedure is repeated until we iterate over the whole
        # clone with no replacement
        i = 0
        while i < len(C):
            f = C[i]    
            for g in C:
                # Add every operation obtained by composing f with
                # g and a number of projections 
                for t in it.product(C[0:arity],repeat=f.arity-1):
                    t = list(t)
                    for j in range(arity):
                        t.insert(j,g)
                        h = f.compose(t)
                        if not h in C:
                            C.append(h)
                        if log:
                            print (count,h)
                            count += 1                        
                        del t[j]
            i += 1
        return Clone(C)
